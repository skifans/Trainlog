{% extends "bootstrap/layout.html" %}
{% block content %}

{% include nav%}

<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>

<!-- Loading screen -->
<div id="loadingScreen" style="position: fixed; width: 100%; height: 100%; top: 0; left: 0; background: rgba(255, 255, 255, 0.8); z-index: 9999; display: flex; justify-content: center; align-items: center;">
    <div class="spinner-border text-primary" role="status">
        <span class="sr-only">Loading...</span>
    </div>
</div>

<div id="statsSelectWrapper" class="d-flex flex-wrap mb-3">
    <select id="statsSelectTripType" class="form-select statsSelect mr-2">
        {%if is_public %}
            <option value="combined" {% if tripType == 'combined' %}selected{% endif %}>
                {{all}}
            </option>
            {% for type, data in publicDistinctTypes.items() %}
                <option value="{{ type }}" {% if tripType == type %}selected{% endif %}>
                {{ data }}
                </option>
            {% endfor %}       
        {%else%}
            <option value="combined" {% if tripType == 'combined' %}selected{% endif %}>
                {{all}}
            </option>
            {% for type, data in distinctTypes.items() %}
                <option value="{{ type }}" {% if tripType == type %}selected{% endif %}>
                {{ data.label }}
                </option>
            {% endfor %}
        {% endif %}
    </select>

    <select id="statsSelectYear" class="form-select statsSelect mr-2">
        <option value="all" {% if not statYear %}selected{% endif %}>{{all}}</option>
        {% for year in distinctStatYears %}
            <option value="{{ year }}" {% if year == statYear %}selected{% endif %}>{{ year }}</option>
        {% endfor %}
    </select>
    
    <div id="metricSelectorWrapper" class="mr-2"></div>
</div>

<div class="noDataDiv" style='display:none;'>
    <br><br><center><h3>{{noData}}</h3></center>
</div>

<div class="container" style="max-width:95%">
    <div class="row">
        <div class="col-md-4">
            <div class="chart-container position-relative">
                <button class="btn btn-light btn-sm expand-button position-absolute top-0 end-0 m-2" onclick="expandChart('chart-countries')" style="z-index: 1000;">
                    <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
                </button>
                <div id="chart-countries" style="width: 100%; height: 400px;"></div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="chart-container position-relative">
                <button class="btn btn-light btn-sm expand-button position-absolute top-0 end-0 m-2" onclick="expandChart('chart-operators')" style="z-index: 1000;">
                    <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
                </button>
                <div id="chart-operators" style="width: 100%; height: 400px;"></div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="chart-container position-relative">
                <button class="btn btn-light btn-sm expand-button position-absolute top-0 end-0 m-2" onclick="expandChart('chart-years')" style="z-index: 1000;">
                    <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
                </button>
                <div id="chart-years" style="width: 100%; height: 400px;"></div>
            </div>
        </div>
    </div>
    <div class="row mt-5">
        <div class="col-md-4">
            <div class="chart-container position-relative">
                <button class="btn btn-light btn-sm expand-button position-absolute top-0 end-0 m-2" onclick="expandChart('chart-material')" style="z-index: 1000;">
                    <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
                </button>
                <div id="chart-material" style="width: 100%; height: 400px;"></div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="chart-container position-relative">
                <button class="btn btn-light btn-sm expand-button position-absolute top-0 end-0 m-2" onclick="expandChart('chart-routes')" style="z-index: 1000;">
                    <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
                </button>
                <div id="chart-routes" style="width: 100%; height: 400px;"></div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="chart-container position-relative">
                <button class="btn btn-light btn-sm expand-button position-absolute top-0 end-0 m-2" onclick="expandChart('chart-stations')" style="z-index: 1000;">
                    <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
                </button>
                <div id="chart-stations" style="width: 100%; height: 400px;"></div>
            </div>
        </div>
    </div>
</div>

<div id="fullscreenContainer" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.85); z-index: 10000;">
    <button id="closeFullscreenButton" class="btn btn-danger position-absolute top-0 end-0 m-2" style="z-index: 10001;">
        <i class="fa-solid fa-xmark"></i>
    </button>
    <div id="fullscreenChart" style="width: 100%; height: 100%; background: rgba(255, 255, 255, 0.75);"></div>
</div>

<div style="height: 100px;"></div>

<script type="text/javascript">
    // ============================================
    // METRICS CONFIGURATION
    // ============================================
    const LANG = "{{langId}}";

    const METRICS_CONFIG = {
        trips: {
            label: '{{trips}}',
            suffix: 'Trips',
            formatValue: (value) => new Intl.NumberFormat(LANG).format(value) + ' {{trips}}',
            enabled: true
        },
        km: {
            label: '{{km}}',
            suffix: 'Km',
            // raw value is meters â†’ format as kilometers with unit handled by Intl
            formatValue: (value) => mToKm(value) + ' km',
            enabled: true
        },
        duration: {
            label: '{{tripDuration}}',
            suffix: 'Duration',
            formatValue: (value) => secondsToDhm(value, LANG, "long"),
            enabled: true
        },
        carbon: {
            label: '{{CO2}}',
            suffix: 'CO2',
            formatValue: (value) => formatCarbonFootprint(value, LANG),
            enabled: true
        }
    };

    // Trip type labels for combined mode
    const TRIP_TYPE_LABELS = {
        'air': '{{distinctTypes.air.label if distinctTypes.air else "Air"}}',
        'helicopter': '{{distinctTypes.helicopter.label if distinctTypes.helicopter else "Helicopter"}}',
        'train': '{{distinctTypes.train.label if distinctTypes.train else "Train"}}',
        'tram': '{{distinctTypes.tram.label if distinctTypes.tram else "Tram"}}',
        'metro': '{{distinctTypes.metro.label if distinctTypes.metro else "Metro"}}',
        'bus': '{{distinctTypes.bus.label if distinctTypes.bus else "Bus"}}',
        'ferry': '{{distinctTypes.ferry.label if distinctTypes.ferry else "Ferry"}}',
        'car': '{{distinctTypes.car.label if distinctTypes.car else "Car"}}',
        'cycle': '{{distinctTypes.cycle.label if distinctTypes.cycle else "Cycle"}}',
        'walk': '{{distinctTypes.walk.label if distinctTypes.walk else "Walk"}}',
        'aerialway': '{{distinctTypes.aerialway.label if distinctTypes.aerialway else "Aerialway"}}'
    };

    // Available trip types from backend
    const AVAILABLE_TRIP_TYPES = [
        {%if is_public %}
            {% for type in publicDistinctTypes.keys() %}'{{ type }}',{% endfor %}
        {%else%}
            {% for type in distinctTypes.keys() %}'{{ type }}',{% endfor %}
        {% endif %}
    ];

    function getEnabledMetrics() {
        return Object.keys(METRICS_CONFIG).filter(key => METRICS_CONFIG[key].enabled);
    }

    // ============================================
    // GLOBAL STATE & UTILITIES
    // ============================================
    var tripType = "{{tripType}}";
    var username = "{{username}}";
    var statYear = "{{statYear if statYear else ''}}";
    var yearDefined = "{{ 'true' if statYear is not none else 'false' }}";
    var isCombinedMode = tripType === 'combined';
    
    var currentMetric = 'trips';
    var statsData = null;
    var combinedStatsData = null;
    var chartsInstances = {};
    var currentChart = null;
    var expandedMode = false;

    var operatorImages = {{logosList | safe}};
    var staticLink = "{{ url_for('resize_image', max_width=240, target_height=40, image_path='')}}";

    function getScreenSize() {
        return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    }

    function isMobile() {
        return getScreenSize() < 750;
    }

    function calculateMaxValue(dataArray) {
        if (!dataArray || dataArray.length === 0) return 0;
        
        const values = dataArray.map(item => {
            if (isCombinedMode) {
                // In combined mode, sum up the values from all trip types within the item
                return Object.values(item.tripTypes || {}).reduce((sum, t) => sum + (t.past || 0) + (t.plannedFuture || 0), 0);
            } else {
                // In single mode, just sum past and plannedFuture
                return (item.past || 0) + (item.plannedFuture || 0);
            }
        });
        
        return Math.max(...values);
    }

    function getDurationAxisConfig(maxSeconds, lang) {
    // Define time units in seconds
    const YEAR_S = 31557600;   // 365.25 * 24 * 3600
    const MONTH_S = 2629800;    // 30.4375 * 24 * 3600
    const WEEK_S = 604800;      // 7 * 24 * 3600
    const DAY_S = 86400;
    const HOUR_S = 3600;
    const MINUTE_S = 60;
    
    let unit = 'second';
    let divisor = 1;
    let interval;
    
    // Helper function to find the best interval with nice multiples
    function findNiceInterval(maxValue, baseUnit, niceMultiples) {
        const targetTicks = 5; // Aim for around 5-10 ticks
        const targetInterval = maxValue / targetTicks;
        
        // Find the closest nice multiple
        let bestInterval = niceMultiples[0] * baseUnit;
        for (const multiple of niceMultiples) {
            const candidateInterval = multiple * baseUnit;
            if (candidateInterval >= targetInterval) {
                bestInterval = candidateInterval;
                break;
            }
        }
        return bestInterval;
    }
    
    // Determine the Scale and Interval
    if (maxSeconds >= 2 * YEAR_S) {
        unit = 'year';
        divisor = YEAR_S;
        interval = findNiceInterval(maxSeconds, YEAR_S, [1, 2, 5, 10, 20, 50, 100]);
    } else if (maxSeconds >= 2 * MONTH_S) {
        unit = 'month';
        divisor = MONTH_S;
        interval = findNiceInterval(maxSeconds, MONTH_S, [1, 2, 3, 6, 12]);
    } else if (maxSeconds >= 2 * WEEK_S) {
        unit = 'week';
        divisor = WEEK_S;
        interval = findNiceInterval(maxSeconds, WEEK_S, [1, 2, 4, 8, 12]);
    } else if (maxSeconds >= 2 * DAY_S) {
        unit = 'day';
        divisor = DAY_S;
        interval = findNiceInterval(maxSeconds, DAY_S, [1, 2, 3, 7, 14, 30]);
    } else if (maxSeconds >= 2 * HOUR_S) {
        unit = 'hour';
        divisor = HOUR_S;
        interval = findNiceInterval(maxSeconds, HOUR_S, [1, 2, 3, 6, 12, 24]);
    } else if (maxSeconds >= 2 * MINUTE_S) {
        unit = 'minute';
        divisor = MINUTE_S;
        interval = findNiceInterval(maxSeconds, MINUTE_S, [1, 2, 5, 10, 15, 30, 60]);
    } else {
        // For seconds, use nice intervals
        const niceIntervals = [1, 2, 5, 10, 15, 30, 60];
        const targetInterval = maxSeconds / 5;
        interval = niceIntervals.find(i => i >= targetInterval) || 1;
    }
    
    const axisMax = Math.ceil(maxSeconds / interval) * interval;
    
    return {
        type: 'value',
        min: 0,
        max: axisMax,
        interval: interval,
        axisLabel: {
            formatter: function (value) {
                const displayValue = value / divisor;
                return new Intl.NumberFormat(lang, {
                    style: 'unit',
                    unit: unit,
                    unitDisplay: 'short',
                    maximumFractionDigits: 0
                }).format(displayValue);
            }
        }
    };
}

    function normalizeKey(input) {
        return input
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "")
            .replace(/[^a-zA-Z0-9 ]/g, "")
            .replace(/\s+/g, '_')
            .toLowerCase();
    }

    function showLoading() {
        document.getElementById('loadingScreen').style.display = 'flex';
    }

    function hideLoading() {
        document.getElementById('loadingScreen').style.display = 'none';
    }

    window.addEventListener('resize', function() {
        Object.keys(chartsInstances).forEach(key => {
            if (chartsInstances[key]) {
                chartsInstances[key].resize();
            }
        });
    });

    // ============================================
    // UI CREATION
    // ============================================
    function createMetricSelector() {
        const enabledMetrics = getEnabledMetrics();
        return `
            <select id="metricSelector" class="form-select statsSelect">
                ${enabledMetrics.map(metric => `
                    <option value="${metric}" ${metric === currentMetric ? 'selected' : ''}>
                        ${METRICS_CONFIG[metric].label}
                    </option>
                `).join('')}
            </select>
        `;
    }

    function attachMetricSelectorListener() {
        const selector = document.getElementById('metricSelector');
        selector.addEventListener('change', function() {
            switchMetric(this.value);
        });
    }

    // ============================================
    // DATA EXTRACTION
    // ============================================
    function extractDataForMetric(data, metric) {
        const config = METRICS_CONFIG[metric];
        const suffix = config.suffix;
        
        function convertItem(item) {
            const converted = {};
            
            // Copy identifier fields
            if (item.country) converted.country = item.country;
            if (item.operator) converted.operator = item.operator;
            if (item.material) converted.material = item.material;
            if (item.route) converted.route = item.route;
            if (item.station) converted.station = item.station;
            if (item.year !== undefined) converted.year = item.year;
            if (item.tripType) converted.tripType = item.tripType;
            
            // Extract metric values (store raw numbers only)
            if (item['past' + suffix] !== undefined) {
                converted.past = item['past' + suffix] || 0;
                converted.plannedFuture = item['plannedFuture' + suffix] || 0;
                if (item['future' + suffix] !== undefined) {
                    converted.future = item['future' + suffix] || 0;
                }
            } else if (item.pastKm !== undefined && suffix === 'Km') {
                converted.past = item.pastKm || 0;
                converted.plannedFuture = item.plannedFutureKm || 0;
                if (item.futureKm !== undefined) {
                    converted.future = item.futureKm || 0;
                }
            } else {
                converted.past = item.past || 0;
                converted.plannedFuture = item.plannedFuture || 0;
                if (item.future !== undefined) {
                    converted.future = item.future || 0;
                }
            }
            
            return converted;
        }
        
        function sortByTotal(arr) {
            return arr.map(convertItem).sort((a, b) => 
                (b.past + b.plannedFuture) - (a.past + a.plannedFuture)
            );
        }
        
        return {
            countries: sortByTotal(data.countries || []),
            operators: sortByTotal(data.operators || []),
            material: sortByTotal(data.material || []),
            routes: (data.routes || []).map(convertItem).sort((a, b) => 
                (b.past + b.plannedFuture + (b.future || 0)) - (a.past + a.plannedFuture + (a.future || 0))
            ),
            stations: (data.stations || []).map(convertItem).sort((a, b) => 
                (b.past + b.plannedFuture + (b.future || 0)) - (a.past + a.plannedFuture + (a.future || 0))
            ),
            years: (data.years || []).map(convertItem)
        };
    }

    // ============================================
    // COMBINED MODE DATA MERGING
    // ============================================
    function mergeCombinedData(allTypeData) {
        const merged = {
            countries: {},
            operators: {},
            material: {},
            routes: {},
            stations: {},
            years: {}
        };

        // Merge data from all trip types
        Object.keys(allTypeData).forEach(tripType => {
            const data = allTypeData[tripType];
            
            // Merge countries
            (data.countries || []).forEach(item => {
                const key = item.country;
                if (!merged.countries[key]) {
                    merged.countries[key] = { country: key, tripTypes: {} };
                }
                if (!merged.countries[key].tripTypes[tripType]) {
                    merged.countries[key].tripTypes[tripType] = { past: 0, plannedFuture: 0, future: 0 };
                }
                merged.countries[key].tripTypes[tripType].past += item.past || 0;
                merged.countries[key].tripTypes[tripType].plannedFuture += item.plannedFuture || 0;
                merged.countries[key].tripTypes[tripType].future += item.future || 0;
            });

            // Merge operators
            (data.operators || []).forEach(item => {
                const key = item.operator;
                if (!merged.operators[key]) {
                    merged.operators[key] = { operator: key, tripTypes: {} };
                }
                if (!merged.operators[key].tripTypes[tripType]) {
                    merged.operators[key].tripTypes[tripType] = { past: 0, plannedFuture: 0, future: 0 };
                }
                merged.operators[key].tripTypes[tripType].past += item.past || 0;
                merged.operators[key].tripTypes[tripType].plannedFuture += item.plannedFuture || 0;
                merged.operators[key].tripTypes[tripType].future += item.future || 0;
            });

            // Merge material
            (data.material || []).forEach(item => {
                const key = item.material;
                if (!merged.material[key]) {
                    merged.material[key] = { material: key, tripTypes: {} };
                }
                if (!merged.material[key].tripTypes[tripType]) {
                    merged.material[key].tripTypes[tripType] = { past: 0, plannedFuture: 0, future: 0 };
                }
                merged.material[key].tripTypes[tripType].past += item.past || 0;
                merged.material[key].tripTypes[tripType].plannedFuture += item.plannedFuture || 0;
                merged.material[key].tripTypes[tripType].future += item.future || 0;
            });

            // Merge routes
            (data.routes || []).forEach(item => {
                const key = item.route;
                if (!merged.routes[key]) {
                    merged.routes[key] = { route: key, tripTypes: {} };
                }
                if (!merged.routes[key].tripTypes[tripType]) {
                    merged.routes[key].tripTypes[tripType] = { past: 0, plannedFuture: 0, future: 0 };
                }
                merged.routes[key].tripTypes[tripType].past += item.past || 0;
                merged.routes[key].tripTypes[tripType].plannedFuture += item.plannedFuture || 0;
                merged.routes[key].tripTypes[tripType].future += item.future || 0;
            });

            // Merge stations
            (data.stations || []).forEach(item => {
                const key = item.station;
                if (!merged.stations[key]) {
                    merged.stations[key] = { station: key, tripTypes: {} };
                }
                if (!merged.stations[key].tripTypes[tripType]) {
                    merged.stations[key].tripTypes[tripType] = { past: 0, plannedFuture: 0, future: 0 };
                }
                merged.stations[key].tripTypes[tripType].past += item.past || 0;
                merged.stations[key].tripTypes[tripType].plannedFuture += item.plannedFuture || 0;
                merged.stations[key].tripTypes[tripType].future += item.future || 0;
            });

            // Merge years
            (data.years || []).forEach(item => {
                const key = item.year;
                if (!merged.years[key]) {
                    merged.years[key] = { year: key, tripTypes: {} };
                }
                if (!merged.years[key].tripTypes[tripType]) {
                    merged.years[key].tripTypes[tripType] = { past: 0, plannedFuture: 0, future: 0 };
                }
                merged.years[key].tripTypes[tripType].past += item.past || 0;
                merged.years[key].tripTypes[tripType].plannedFuture += item.plannedFuture || 0;
                merged.years[key].tripTypes[tripType].future += item.future || 0;
            });
        });

        // Convert objects to sorted arrays
        function sortMergedData(obj, sortKey) {
            return Object.values(obj).sort((a, b) => {
                const aTotal = Object.values(a.tripTypes).reduce((sum, t) => sum + t.past + t.plannedFuture, 0);
                const bTotal = Object.values(b.tripTypes).reduce((sum, t) => sum + t.past + t.plannedFuture, 0);
                return bTotal - aTotal;
            });
        }

        return {
            countries: sortMergedData(merged.countries),
            operators: sortMergedData(merged.operators),
            material: sortMergedData(merged.material),
            routes: sortMergedData(merged.routes),
            stations: sortMergedData(merged.stations),
            years: Object.values(merged.years).sort((a, b) => a.year - b.year)
        };
    }

    function groupData(data, key) {
        if (data.length <= 10) {
            return data;
        }
        var grouped = data.slice(0, 10);
        
        if (isCombinedMode) {
            // For combined mode, merge tripTypes for "others"
            var others = data.slice(10).reduce((acc, item) => {
                Object.keys(item.tripTypes || {}).forEach(tripType => {
                    if (!acc.tripTypes[tripType]) {
                        acc.tripTypes[tripType] = { past: 0, plannedFuture: 0, future: 0 };
                    }
                    acc.tripTypes[tripType].past += item.tripTypes[tripType].past || 0;
                    acc.tripTypes[tripType].plannedFuture += item.tripTypes[tripType].plannedFuture || 0;
                    acc.tripTypes[tripType].future += item.tripTypes[tripType].future || 0;
                });
                return acc;
            }, { [key]: '{{others}}', tripTypes: {} });
            grouped.push(others);
        } else {
            var others = data.slice(10).reduce((acc, item) => {
                acc.past += item.past;
                acc.plannedFuture += item.plannedFuture;
                return acc;
            }, { [key]: '{{others}}', past: 0, plannedFuture: 0 });
            grouped.push(others);
        }
        
        return grouped;
    }

    // ============================================
    // CHART STYLING
    // ============================================
    function createPattern(color) {
        var canvas = document.createElement('canvas');
        canvas.width = 4;
        canvas.height = 4;
        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(4, 0);
        ctx.lineTo(0, 4);
        ctx.stroke();
        
        return {
            type: 'pattern',
            image: canvas,
            repeat: 'repeat'
        };
    }

    function getColor(type) {
        var colorMap = {
            'air': 'rgb(64, 185, 31)',
            'helicopter': 'rgb(64, 185, 31)',
            'train': 'rgb(82, 176, 254)',
            'tram': 'rgb(162, 215, 255)',
            'metro': 'rgb(0, 69, 149)',
            'bus': 'rgb(159, 75, 187)',
            'ferry': 'rgb(30, 30, 124)',
            'car': 'rgb(166, 143, 205)',
            'cycle': 'rgb(110, 33, 26)',
            'walk': 'rgb(232, 140, 0)',
            'aerialway': 'rgb(175, 207, 59)'
        };
        return colorMap[type] || '#000000';
    }

    function createSeries(data, color) {
        if (isCombinedMode) {
            return createCombinedSeries(data);
        }
        
        return [
            {
                name: '{{past}}',
                type: 'bar',
                stack: 'Total',
                data: data.map(item => ({ value: item.past, itemStyle: { color: color } }))
            },
            {
                name: '{{plannedFuture}}',
                type: 'bar',
                stack: 'Total',
                data: data.map(item => ({ 
                    value: item.plannedFuture,
                    itemStyle: { color: createPattern(color) }
                }))
            }
        ];
    }

    function createCombinedSeries(data) {
        const series = [];
        
        // Create series for each trip type (past and planned future)
        AVAILABLE_TRIP_TYPES.forEach(tripType => {
            const color = getColor(tripType);
            const label = TRIP_TYPE_LABELS[tripType] || tripType;
            
            // Past trips for this type
            series.push({
                name: `${label} ({{past}})`,
                type: 'bar',
                stack: 'Total',  // Changed from 'Past' to 'Total'
                data: data.map(item => {
                    const tripTypeData = item.tripTypes && item.tripTypes[tripType];
                    return {
                        value: tripTypeData ? tripTypeData.past : 0,
                        itemStyle: { color: color }
                    };
                })
            });
            
            // Planned future trips for this type
            series.push({
                name: `${label} ({{plannedFuture}})`,
                type: 'bar',
                stack: 'Total',  // Changed from 'Future' to 'Total'
                data: data.map(item => {
                    const tripTypeData = item.tripTypes && item.tripTypes[tripType];
                    return {
                        value: tripTypeData ? tripTypeData.plannedFuture : 0,
                        itemStyle: { color: createPattern(color) }
                    };
                })
            });
        });
        
        return series;
    }

    // ============================================
    // CHART RENDERING
    // ============================================
    function commonTooltipFormatter(params) {
        const config = METRICS_CONFIG[currentMetric];
        let result = params[0].name + '<br/>';

        if (isCombinedMode) {
            // Group by trip type
            const byTripType = {};
            let totalPast = 0;
            let totalFuture = 0;
            
            params.forEach(item => {
                if (item.value > 0) {
                    // Extract trip type and status from series name
                    const match = item.seriesName.match(/^(.+?) \(({{past}}|{{plannedFuture}})\)$/);
                    if (match) {
                        const tripTypeLabel = match[1];
                        const status = match[2];
                        
                        if (!byTripType[tripTypeLabel]) {
                            byTripType[tripTypeLabel] = { past: 0, future: 0 };
                        }
                        
                        if (status === '{{past}}') {
                            byTripType[tripTypeLabel].past = item.value;
                            totalPast += item.value;
                        } else {
                            byTripType[tripTypeLabel].future = item.value;
                            totalFuture += item.value;
                        }
                    }
                }
            });
            
            // Display grouped by trip type
            Object.keys(byTripType).forEach(tripTypeLabel => {
                const data = byTripType[tripTypeLabel];
                result += `<strong>${tripTypeLabel}</strong><br/>`;
                
                if (data.past > 0) {
                    result += `&nbsp;&nbsp;{{past}}: ${config.formatValue(data.past)}<br/>`;
                }
                if (data.future > 0) {
                    result += `&nbsp;&nbsp;{{plannedFuture}}: ${config.formatValue(data.future)}<br/>`;
                }
            });
            
            // Add totals
            if (totalPast > 0 || totalFuture > 0) {
                result += '<br/><strong>Total</strong><br/>';
                if (totalPast > 0) {
                    result += `&nbsp;&nbsp;{{past}}: ${config.formatValue(totalPast)}<br/>`;
                }
                if (totalFuture > 0) {
                    result += `&nbsp;&nbsp;{{plannedFuture}}: ${config.formatValue(totalFuture)}<br/>`;
                }
            }
        } else {
            params.forEach(function(item) {
                if (item.value > 0) {
                    let marker;
                    if (item.seriesName === '{{plannedFuture}}') {
                        const pattern = createPattern(getColor(tripType));
                        const patternURL = pattern.image.toDataURL();
                        marker = `<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background:url(${patternURL});"></span>`;
                    } else {
                        marker = item.marker;
                    }
                    result += `${marker} ${item.seriesName}: ${config.formatValue(item.value)}<br/>`;
                }
            });
        }

        return result;
    }

    function renderCharts(data) {
        var hGridConfig = {
            bottom: '28px',
            left: isMobile() ? '60px' : '120px'
        };
        var vGridConfig = {
            bottom: '120px',
            left: '28px'
        };
        var yGridConfig = {
            bottom: '28px',
            left: '28px'
        };
        var commonTooltipConfig = {
            trigger: 'axis',
            axisPointer: { type: 'shadow' },
            formatter: commonTooltipFormatter,
            confine: true,  // ADD THIS - keeps tooltip within chart container
            appendToBody: true,  // ADD THIS - appends to body for better positioning
            position: function (point, params, dom, rect, size) {
                // Custom position to prevent overflow
                var x = point[0];
                var y = point[1];
                var viewWidth = size.viewSize[0];
                var viewHeight = size.viewSize[1];
                var boxWidth = size.contentSize[0];
                var boxHeight = size.contentSize[1];
                
                // Adjust horizontal position
                if (x + boxWidth > viewWidth) {
                    x = viewWidth - boxWidth - 10;
                }
                
                // Adjust vertical position
                if (y + boxHeight > viewHeight) {
                    y = viewHeight - boxHeight - 10;
                }
                
                return [x, y];
            }
        };

        var dataToUse = expandedMode ? data : {
            countries: groupData(data.countries, 'country'),
            operators: groupData(data.operators, 'operator'),
            routes: groupData(data.routes, 'route'),
            stations: groupData(data.stations, 'station'),
            material: groupData(data.material, 'material'),
            years: data.years
        };

        var truncateLabel = function(label) {
            return label.length > 15 ? label.slice(0, 12) + '...' : label;
        };

        var commonCatAxisOptions = {
            type: 'category',
            axisLabel: {
                rotate: 40,
                formatter: function(value) {
                    return expandedMode ? value : truncateLabel(value);
                }
            }
        };

        var commonValAxisOptions = {
            type: 'value',
            min: undefined,
            max: undefined,
            interval: undefined,
            axisLabel: {
                formatter: function (value) {
                    if(currentMetric === 'km'){
                        return mToKm(value) + ' km';
                    }
                    else if (currentMetric === 'carbon'){
                        return value >= 1e9 ? (value / 1e9) + ' Mt' : value >= 1e6 ? (value / 1e6) + ' kt' : value >= 1e3 ? (value / 1e3) + ' t' : value + ' kg';
                    }
                    return value >= 1000 ? (value / 1000) + 'k' : value;
                }
            }
        };
        
        // Countries Chart
        var countriesMax = calculateMaxValue(dataToUse.countries);
        var countriesValueAxisOptions = (currentMetric === 'duration')
            ? getDurationAxisConfig(countriesMax, LANG)
            : commonValAxisOptions;

        var countriesChart = echarts.init(document.getElementById('chart-countries'));
        chartsInstances['countries'] = countriesChart;
        countriesChart.setOption({
            title: { text: "{{crossedCountries}}" },
            tooltip: commonTooltipConfig,
            yAxis: {
                type: 'category',
                inverse: true,
                axisLabel: {
                    formatter: function (value) {
                        return !isMobile() ? value : value.slice(-5);
                    }
                },
                data: dataToUse.countries.map(item => {
                    return item.country === "{{others}}" ? item.country : `${regionNames.of(item.country)} ${getFlagEmoji(item.country)}`;
                })
            },
            xAxis: countriesValueAxisOptions,
            grid: hGridConfig,
            series: createSeries(dataToUse.countries, getColor(tripType))
        });

        // Operators Chart
        var operatorsMax = calculateMaxValue(dataToUse.operators);
        var operatorsValueAxisOptions = (currentMetric === 'duration')
            ? getDurationAxisConfig(operatorsMax, LANG)
            : commonValAxisOptions;

        var operatorsChart = echarts.init(document.getElementById('chart-operators'));
        chartsInstances['operators'] = operatorsChart;
        operatorsChart.setOption({
            title: { text: "{{operator}}" },
            tooltip: commonTooltipConfig,
            yAxis: {
                type: 'category',
                inverse: true,
                axisLabel: {
                    formatter: function(value) {
                        const normalizedKey = normalizeKey(value);
                        if (operatorImages[value]) {
                            return `{${normalizedKey}|}`;
                        }
                        return value;
                    },
                    rich: Object.assign({}, ...Object.keys(operatorImages).map(operator => {
                        const normalizedKey = normalizeKey(operator);
                        return {
                            [normalizedKey]: {
                                width: isMobile() ? 50 : 110,
                                height: isMobile() ? 10 : 20,
                                backgroundColor: {
                                    image: encodeURI(staticLink + operatorImages[operator].replace('&', '%26'))
                                }
                            }
                        };
                    }))
                },
                data: dataToUse.operators.map(item => item.operator)
            },
            xAxis: operatorsValueAxisOptions,
            grid: hGridConfig,
            series: createSeries(dataToUse.operators, getColor(tripType))
        });

        // Years Chart
        var yearsMax = calculateMaxValue(dataToUse.years);
        var yearsValueAxisOptions = (currentMetric === 'duration')
            ? getDurationAxisConfig(yearsMax, LANG)
            : commonValAxisOptions;

        // Years Chart
        var yearsChart = echarts.init(document.getElementById('chart-years'));
        chartsInstances['years'] = yearsChart;
        yearsChart.setOption({
            title: { text: "{{year}}" },
            tooltip: commonTooltipConfig,
            xAxis: {
                type: 'category',
                data: dataToUse.years.map(item => item.year)
            },
            yAxis: yearsValueAxisOptions,
            grid: yGridConfig,
            series: createSeries(dataToUse.years, getColor(tripType))
        });


        var materialMax = calculateMaxValue(dataToUse.material);
        var materialValueAxisOptions = (currentMetric === 'duration')
            ? getDurationAxisConfig(materialMax, LANG)
            : commonValAxisOptions;
        // Material Chart
        var materialChart = echarts.init(document.getElementById('chart-material'));
        chartsInstances['material'] = materialChart;
        if (dataToUse.material.length == 0) {
            $("#chart-material").parent().parent().hide();
        } else {
            $("#chart-material").parent().parent().show();
            materialChart.setOption({
                title: { text: "{{material_type}}" },
                tooltip: commonTooltipConfig,
                xAxis: {
                    ...commonCatAxisOptions,
                    data: dataToUse.material.map(item => item.material)
                },
                yAxis: materialValueAxisOptions,
                grid: vGridConfig,
                series: createSeries(dataToUse.material, getColor(tripType))
            });
        }

        // Routes Chart
        var routesMax = calculateMaxValue(dataToUse.routes);
        var routesValueAxisOptions = (currentMetric === 'duration')
            ? getDurationAxisConfig(routesMax, LANG)
            : commonValAxisOptions;
        var routesChart = echarts.init(document.getElementById('chart-routes'));
        chartsInstances['routes'] = routesChart;
        routesChart.setOption({
            title: { text: '{{routes}}' },
            tooltip: commonTooltipConfig,
            xAxis: {
                ...commonCatAxisOptions,
                data: dataToUse.routes.map(item => {
                    try {
                        return JSON.parse(item.route).join(' - ');
                    } catch(e) {
                        return item.route;
                    }
                })
            },
            yAxis: routesValueAxisOptions,
            grid: vGridConfig,
            series: createSeries(dataToUse.routes, getColor(tripType))
        });

        // Stations Chart
        var stationsMax = calculateMaxValue(dataToUse.stations);
        var stationsValueAxisOptions = (currentMetric === 'duration')
            ? getDurationAxisConfig(stationsMax, LANG)
            : commonValAxisOptions;
        var stationsChart = echarts.init(document.getElementById('chart-stations'));
        chartsInstances['stations'] = stationsChart;
        stationsChart.setOption({
            title: { text: '{{stations}}' },
            tooltip: commonTooltipConfig,
            xAxis: {
                ...commonCatAxisOptions,
                data: dataToUse.stations.map(item => item.station)
            },
            yAxis: stationsValueAxisOptions,
            grid: vGridConfig,
            series: createSeries(dataToUse.stations, getColor(tripType))
        });
    }

    // ============================================
    // DATA FETCHING
    // ============================================
    async function fetchStatsData() {
        var isAdmin = "{{ 'true' if admin else 'false' }}";
        
        var urlPath;
        if (isAdmin === "true") {
            urlPath = statYear 
                ? `/admin/getStats/${statYear}/${tripType}`
                : `/admin/getStats/${tripType}`;
        } else {
            urlPath = statYear 
                ? `/${username}/getStats/${statYear}/${tripType}`
                : `/${username}/getStats/${tripType}`;
        }
            
        try {
            const response = await fetch(urlPath);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return await response.json();
        } catch (error) {
            console.error('Error fetching stats:', error);
            return null;
        }
    }

    async function fetchCombinedStatsData() {
        const allTypeData = {};
        
        for (const type of AVAILABLE_TRIP_TYPES) {
            var isAdmin = "{{ 'true' if admin else 'false' }}";
            
            var urlPath;
            if (isAdmin === "true") {
                urlPath = statYear 
                    ? `/admin/getStats/${statYear}/${type}`
                    : `/admin/getStats/${type}`;
            } else {
                urlPath = statYear 
                    ? `/${username}/getStats/${statYear}/${type}`
                    : `/${username}/getStats/${type}`;
            }
            
            try {
                const response = await fetch(urlPath);
                if (response.ok) {
                    allTypeData[type] = await response.json();
                }
            } catch (error) {
                console.error(`Error fetching stats for ${type}:`, error);
            }
        }
        
        return allTypeData;
    }

    async function fetchDataAndRenderCharts() {
        showLoading();
        try {
            if (isCombinedMode) {
                const allTypeData = await fetchCombinedStatsData();
                
                // Extract data for current metric from each type
                const extractedByType = {};
                Object.keys(allTypeData).forEach(type => {
                    extractedByType[type] = extractDataForMetric(allTypeData[type], currentMetric);
                });
                
                // Merge all types together
                combinedStatsData = allTypeData;
                var mergedData = mergeCombinedData(extractedByType);
                renderCharts(mergedData);
            } else {
                statsData = await fetchStatsData();
                
                if (statsData) {
                    var displayData = extractDataForMetric(statsData, currentMetric);
                    renderCharts(displayData);
                } else {
                    console.error('No data available');
                }
            }
        } catch (error) {
            console.error('Error processing data:', error);
        } finally {
            hideLoading();
        }
    }

    // ============================================
    // METRIC SWITCHING
    // ============================================
    async function switchMetric(newMetric) {
        if (!METRICS_CONFIG[newMetric]?.enabled) return;
        
        currentMetric = newMetric;
        
        if (isCombinedMode) {
            if (!combinedStatsData) return;
            
            // Re-extract data for new metric from cached combined data
            const extractedByType = {};
            Object.keys(combinedStatsData).forEach(type => {
                extractedByType[type] = extractDataForMetric(combinedStatsData[type], currentMetric);
            });
            
            var mergedData = mergeCombinedData(extractedByType);
            renderCharts(mergedData);
        } else {
            if (!statsData) return;
            var displayData = extractDataForMetric(statsData, currentMetric);
            renderCharts(displayData);
        }
    }

    // ============================================
    // FULLSCREEN
    // ============================================
    function expandChart(chartId) {
        expandedMode = true;
        var fullscreenContainer = document.getElementById('fullscreenContainer');
        var fullscreenChart = document.getElementById('fullscreenChart');
        fullscreenContainer.style.display = 'block';
        fullscreenChart.innerHTML = '';

        var chartInstance = echarts.init(fullscreenChart);
        var dataKeyMap = {
            'chart-countries': 'countries',
            'chart-operators': 'operators',
            'chart-routes': 'routes',
            'chart-stations': 'stations',
            'chart-material': 'material',
            'chart-years': 'years'
        };
        var dataKey = dataKeyMap[chartId];
        
        var displayData;
        if (isCombinedMode) {
            const extractedByType = {};
            Object.keys(combinedStatsData).forEach(type => {
                extractedByType[type] = extractDataForMetric(combinedStatsData[type], currentMetric);
            });
            displayData = mergeCombinedData(extractedByType);
        } else {
            displayData = extractDataForMetric(statsData, currentMetric);
        }
        
        var dataToUse = displayData[dataKey];
        var config = METRICS_CONFIG[currentMetric];

        var maxValue = calculateMaxValue(dataToUse);
        var valueAxisOptions = (currentMetric === 'duration')
            ? getDurationAxisConfig(maxValue, LANG)
            : { // Recreate the simple formatter for other metrics
                type: 'value',
                axisLabel: {
                    formatter: function (value) {
                        if(currentMetric === 'km') return mToKm(value) + ' km';
                        else if (currentMetric === 'carbon') return value >= 1e9 ? (value / 1e9) + ' Mt' : value >= 1e6 ? (value / 1e6) + ' kt' : value >= 1e3 ? (value / 1e3) + ' t' : value + ' kg';
                        return value >= 1000 ? (value / 1000) + 'k' : value;
                    }
                }
            };

        var option = {
            title: { 
                text: chartsInstances[dataKey.replace('chart-', '')]?.getOption()?.title?.[0]?.text || ''
            },
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'shadow' },
                formatter: commonTooltipFormatter 
            },
            grid: { 
                containLabel: true, 
                width: '80%', 
                height: '85%',
                bottom: '10%',
                top: '10%'
            },
            series: createSeries(dataToUse, getColor(tripType))
        };

        // Configure axes based on chart type
        if (['countries', 'operators'].includes(dataKey)) {
            option.yAxis = {
                type: 'category',
                inverse: true,
                axisLabel: dataKey === 'operators'
                    ? {
                        formatter: function(value) {
                            const normalizedKey = normalizeKey(value);
                            if (operatorImages[value]) {
                                return `{${normalizedKey}|}`;
                            }
                            return value;
                        },
                        rich: Object.assign({}, ...Object.keys(operatorImages).map(operator => {
                            const normalizedKey = normalizeKey(operator);
                            return {
                                [normalizedKey]: {
                                    width: isMobile() ? 50 : 110,
                                    height: isMobile() ? 10 : 20,
                                    backgroundColor: {
                                        image: encodeURI(staticLink + operatorImages[operator].replace('&', '%26'))
                                    }
                                }
                            };
                        }))
                    }
                    : {
                        formatter: function (value) {
                            return !isMobile() ? value : value.slice(-5);
                        }
                    },
                data: dataToUse.map(item =>
                    dataKey === 'countries'
                        ? (item.country === "{{others}}" ? item.country : `${regionNames.of(item.country)} ${getFlagEmoji(item.country)}`)
                        : item.operator
                )
            };
            option.xAxis = valueAxisOptions;
            
            // Add vertical slider for countries/operators
            option.dataZoom = [
                {
                    type: 'slider',
                    yAxisIndex: 0,
                    top: '70px',
                    right: '20px',
                    startValue: 0,
                    endValue: 20
                }
            ];
        } else {
            option.xAxis = {
                type: 'category',
                axisLabel: { rotate: 45 },
                data: dataToUse.map(item => {
                    if (dataKey === 'material') return item.material;
                    if (dataKey === 'routes') {
                        try { return JSON.parse(item.route).join(' - '); }
                        catch(e) { return item.route; }
                    }
                    if (dataKey === 'years') return item.year;
                    return item.station;
                })
            };
            option.yAxis = valueAxisOptions;
            
            // Add horizontal slider for other charts
            if (dataKey !== 'years') {
                option.dataZoom = [
                    {
                        type: 'slider',
                        xAxisIndex: 0,
                        bottom: '10px',
                        left: '25px',
                        right: '25px',
                        startValue: 0,
                        endValue: 20
                    }
                ];
            }
        }

        chartInstance.setOption(option);
        currentChart = chartInstance;
    }

    document.getElementById('closeFullscreenButton').addEventListener('click', function() {
        expandedMode = false;
        document.getElementById('fullscreenContainer').style.display = 'none';
        if (currentChart) {
            currentChart.dispose();
            currentChart = null;
        }
        
        if (isCombinedMode) {
            const extractedByType = {};
            Object.keys(combinedStatsData).forEach(type => {
                extractedByType[type] = extractDataForMetric(combinedStatsData[type], currentMetric);
            });
            var mergedData = mergeCombinedData(extractedByType);
            renderCharts(mergedData);
        } else {
            var displayData = extractDataForMetric(statsData, currentMetric);
            renderCharts(displayData);
        }
    });

    // ============================================
    // EVENT HANDLERS
    // ============================================
    $("#statsSelectYear").change(function() {
        var selectedYear = $(this).val();
        var isPublic = "{{ 'true' if is_public else 'false' }}";
        var isAdmin = "{{ 'true' if admin else 'false' }}";
        var currentTripType = tripType;

        var redirectUrl;
        if (isAdmin == "true") {
            redirectUrl = selectedYear === "all" ? 
                '{{ url_for("admin_stats", tripType="TRIPTYPE") }}'.replace("TRIPTYPE", currentTripType) :
                '{{ url_for("admin_stats", year="YEAR", tripType="TRIPTYPE") }}'.replace("YEAR", selectedYear).replace("TRIPTYPE", currentTripType);
        } else if (isPublic == "true") {
            redirectUrl = selectedYear === "all" ?
                '{{ url_for("public_stats", username=username, tripType="TRIPTYPE") }}'.replace("TRIPTYPE", currentTripType) :
                '{{ url_for("public_stats", username=username, year="YEAR", tripType="TRIPTYPE") }}'.replace("YEAR", selectedYear).replace("TRIPTYPE", currentTripType);
        } else {
            redirectUrl = selectedYear === "all" ?
                '{{ url_for("stats", username=username, tripType="TRIPTYPE") }}'.replace("TRIPTYPE", currentTripType) :
                '{{ url_for("stats", username=username, year="YEAR", tripType="TRIPTYPE") }}'.replace("YEAR", selectedYear).replace("TRIPTYPE", currentTripType);
        }

        window.location.href = redirectUrl;
    });

    $("#statsSelectTripType").change(function() {
        var newTripType = $(this).val();
        var isPublic = "{{ 'true' if is_public else 'false' }}";
        var isAdmin = "{{ 'true' if admin else 'false' }}";
        
        var redirectUrl;
        if (isAdmin == "true") {
            redirectUrl = yearDefined == "true" ?
                '{{ url_for("admin_stats", year=statYear, tripType="") }}' + newTripType :
                '{{ url_for("admin_stats", tripType="") }}' + newTripType;
        } else if (isPublic == "true") {
            redirectUrl = yearDefined == "true" ?
                '{{ url_for("public_stats", username=username, year=statYear, tripType="") }}' + newTripType :
                '{{ url_for("public_stats", username=username, tripType="") }}' + newTripType;
        } else {
            redirectUrl = yearDefined == "true" ?
                '{{ url_for("stats", username=username, year=statYear, tripType="") }}' + newTripType :
                '{{ url_for("stats", username=username, tripType="") }}' + newTripType;
        }

        window.location.href = redirectUrl;
    });

    // ============================================
    // INITIALIZATION
    // ============================================
    async function initializeStats() {
        const wrapper = document.getElementById('metricSelectorWrapper');
        if (wrapper) {
            wrapper.innerHTML = createMetricSelector();
            attachMetricSelectorListener();
        }
        
        await fetchDataAndRenderCharts();
    }

    initializeStats();
</script>

{% endblock %}