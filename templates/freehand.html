{% extends "layout.html" %}
{% block content %}
<script>

</script>

<div class="mapRouting" id="map">
</div>

<div id="sidebar">
    <div id="sidebar-content">
    </div>
</div>


<script>

    var markerIconStart = L.icon({
        iconUrl: '/static/images/icons/marker-icon-2x-green.png',
        iconRetinaUrl: '/static/images/icons/marker-icon-2x-green.png',
        iconSize:    [25, 41],
        iconAnchor:  [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28],
    });
    var markerIconEnd = L.icon({
        iconUrl: '/static/images/icons/marker-icon-2x-red.png',
        iconRetinaUrl: '/static/images/icons/marker-icon-2x-red.png',
        iconSize:    [25, 41],
        iconAnchor:  [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28],
    });

    var id = getGetParams().get("id");
    var newTrip = JSON.parse(sessionStorage.getItem(id));
    var type = getGetParams().get("type");
    newTrip["type"] = type;

    var origCoord = newTrip["originStation"][0];
    var destCoord = newTrip["destinationStation"][0];
    var origLabel = newTrip["originStation"][1];
    var destLabel = newTrip["destinationStation"][1];

    // This 'points' array is the single source of truth for the route.
    // We standardize on L.latLng objects for consistency.
    var points = [
        L.latLng(origCoord[0], origCoord[1]),
        L.latLng(destCoord[0], destCoord[1])
    ];
    
    var spinnerContent = '<div class="spinner-container"><div class="lds-spinner"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>';
    var errorContent = "<h4> {{routingError}} <h4>";
        errorContent += "<p> {{routingErrorDetails}} </p>";
        errorContent += `<p><button onclick="location.reload()"> {{retry}} </button></p>`;

    var saveErrorContent = "<h4> {{saveError}} </h4>";
        saveErrorContent += "<p> {{saveErrorDetails}} </p>";
        saveErrorContent += `<p><button onclick="location.reload();"> {{retry}} </button></p>`;

    var map = createMap(null,origCoord);
    var sidebar;

    if (window.innerWidth > 600){
        var autoPan = true;
    } else {
        var autoPan = false;
    }

    sidebar = L.control.sidebar('sidebar', {
        closeButton: true,
        position: 'right',
        autoPan: autoPan
    }).addTo(map);
    sidebar.setContent(spinnerContent);

    L.Control.MyControl = L.Control.extend({
        onAdd: function(map) {
            var el = L.DomUtil.create('div', 'leaflet-bar');
            el.innerHTML += '<button class="button" onclick="sidebar.show()">⬅️</button>';
            return el;
        }
    });

    L.control.myControl = function(opts) {
        return new L.Control.MyControl(opts);
    }

    L.control.myControl({
        position: 'topright'
    }).addTo(map);


    var geodesic; // Will hold the polyline layer
    var waypointMarkers = []; // Will hold intermediate markers
    var path; // Will hold the final path for saving

    // Create the persistent start and end markers
    // They are created once and manage their own state.
    var origMarker = L.marker(points[0], {icon:markerIconStart, draggable: true}).addTo(map);
    var destMarker = L.marker(points[points.length - 1], {icon:markerIconEnd, draggable: true}).addTo(map);

    origMarker.on('dragend', () => {
        // 1. Update the source of truth
        points[0] = origMarker.getLatLng();
        // 2. Redraw everything
        refreshPolyline();
    });

    destMarker.on('dragend', () => {
        // 1. Update the source of truth
        points[points.length - 1] = destMarker.getLatLng();
        // 2. Redraw everything
        refreshPolyline();
    });

    map.fitBounds(new L.LatLngBounds(points), {padding: [50,50]});

    // Initial draw
    refreshPolyline();

    function getClosestSegmentIndex(points, clickedPoint) {
        var minDistance = Infinity;
        var closestSegmentIndex = -1;

        for (var i = 0; i < points.length - 1; i++) {
            var segmentStart = points[i];
            var segmentEnd = points[i + 1];

            // This line calculates the minimum distance between a point and a line segment
            var distance = L.GeometryUtil.length([clickedPoint, L.GeometryUtil.closest(map, [segmentStart, segmentEnd], clickedPoint)]);

            if (distance < minDistance) {
                minDistance = distance;
                closestSegmentIndex = i;
            }
        }
        return closestSegmentIndex;
    }

    function refreshPolyline() {
        
        // 1. Remove old layers
        if (geodesic) {
            map.removeLayer(geodesic);
        }
        // Remove all old intermediate markers
        waypointMarkers.forEach(function(marker) {
            map.removeLayer(marker);
        });
        waypointMarkers = []; // Clear the array

        // 2. Create new polyline from the source of truth ('points')
        geodesic = new L.Geodesic(points, { className: "polyline ferryPolyline pastPolyline", wrap:false, steps:8 }).addTo(map);

        // 3. Attach click handler to the *new* line
        geodesic.on('click', function (e) {
            var clickedPoint = e.latlng;
            var closestSegmentIndex = getClosestSegmentIndex(points, clickedPoint);

            // 1. Update the source of truth
            points.splice(closestSegmentIndex + 1, 0, clickedPoint);

            // 2. Redraw everything (this fixes the "unlock" bug)
            refreshPolyline();
        });

        // 4. Re-create all intermediate waypoint markers (skip start/end)
        for (let i = 1; i < points.length - 1; i++) {
            let waypointMarker = L.marker(points[i], {draggable: true}).addTo(map);
            waypointMarkers.push(waypointMarker); // Add to array for removal next time

            // Attach drag handler that knows its correct index in 'points'
            waypointMarker.on('dragend', function () {
                // 'this' is the marker that was dragged
                // 'i' is its index from when the handler was created
                points[i] = this.getLatLng();
                refreshPolyline();
            });
        }

        // 5. Update sidebar and trip data
        var distance = 0;
        for (let i = 1; i < points.length; i++) {
            // Assuming getDistanceFromLocations can handle L.latLng objects
            distance += getDistanceFromLocations(points[i-1], points[i]);
        }
        
        var content = `<h4>${origLabel} to ${destLabel}</h4>`;
        var km = mToKm(distance);
        var sailingTime = (distance / 30) * 3.6;
        var time = secondsToDhm(sailingTime, "{{langId}}");
        content += `<p><i>${km} km, ${time}</i></p>`;
        content += `<p><button id="saveTrip" type="button" onclick="saveTrip()"> Submit </button></p>`;

        newTrip["trip_length"] = distance;
        newTrip["estimated_trip_duration"] = sailingTime;

        path = geodesic.getLatLngs()[0];
        console.log(path);
        sidebar.setContent(content);
    }

    async function saveTrip(){
        sidebar.setContent(spinnerContent);
        $.post({
            url:'{{url_for("saveTrip", username=username)}}',
            data:{
                newTrip:JSON.stringify(newTrip),
                jsonPath:JSON.stringify(path)
            },
            success: function(res) {
                location.href = "{{ url_for('landing') }}";
            },
            error: function() {
                sidebar.setContent(saveErrorContent);
            }
        });
    }

    setTimeout(function () {
        sidebar.show();
    }, 500);
</script>
{% endblock %}